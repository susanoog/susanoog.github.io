<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Susanow: /home/slank/git/susanow/lthread/lthread_diag_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Susanow
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_dfefae42a4cf55ba0761ace7a8746e62.html">susanow</a></li><li class="navelem"><a class="el" href="dir_a03b4f5d9147e1842fb1c504fc389932.html">lthread</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lthread_diag_api.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;inttypes.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for lthread_diag_api.h:</div>
<div class="dyncontent">
<div class="center"><img src="lthread__diag__api_8h__incl.png" border="0" usemap="#_2home_2slank_2git_2susanow_2lthread_2lthread__diag__api_8h" alt=""/></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="lthread__diag__api_8h__dep__incl.png" border="0" usemap="#_2home_2slank_2git_2susanow_2lthread_2lthread__diag__api_8hdep" alt=""/></div>
<map name="_2home_2slank_2git_2susanow_2lthread_2lthread__diag__api_8hdep" id="_2home_2slank_2git_2susanow_2lthread_2lthread__diag__api_8hdep">
<area shape="rect" id="node2" href="lthread__diag_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_diag.h" alt="" coords="469,95,651,136"/>
<area shape="rect" id="node3" href="lthread_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread.h" alt="" coords="534,184,717,225"/>
<area shape="rect" id="node4" href="lthread__int_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_int.h" alt="" coords="275,273,458,315"/>
<area shape="rect" id="node6" href="lthread__sched_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_sched.h" alt="" coords="246,631,437,672"/>
<area shape="rect" id="node7" href="lthread__queue_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_queue.h" alt="" coords="465,452,655,493"/>
<area shape="rect" id="node8" href="lthread__objcache_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_objcache.h" alt="" coords="93,541,304,583"/>
<area shape="rect" id="node11" href="lthread__pool_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_pool.h" alt="" coords="430,363,613,404"/>
<area shape="rect" id="node5" href="lthread__timer_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_timer.h" alt="" coords="103,720,294,761"/>
<area shape="rect" id="node9" href="lthread__mutex_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_mutex.h" alt="" coords="638,541,829,583"/>
<area shape="rect" id="node10" href="lthread__cond_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_cond.h" alt="" coords="379,541,562,583"/>
</map>
</div>
</div>
<p><a href="lthread__diag__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a636547487099166286ae81fafe2df84b"><td class="memItemLeft" align="right" valign="top"><a id="a636547487099166286ae81fafe2df84b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LTHREAD_DIAG</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a636547487099166286ae81fafe2df84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d61be7e7c8432ae1dfe1c04642f9155"><td class="memItemLeft" align="right" valign="top"><a id="a7d61be7e7c8432ae1dfe1c04642f9155"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LT_DIAG_ALL</b>&#160;&#160;&#160;0xffffffffffffffff</td></tr>
<tr class="separator:a7d61be7e7c8432ae1dfe1c04642f9155"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4b8cb559ed8a8bb2a048092658b58d67"><td class="memItemLeft" align="right" valign="top"><a id="a4b8cb559ed8a8bb2a048092658b58d67"></a>
typedef uint64_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>diag_callback</b>) (uint64_t time, struct <a class="el" href="structlthread.html">lthread</a> *lt, int diag_event, uint64_t diag_ref, const char *text, uint64_t p1, uint64_t p2)</td></tr>
<tr class="separator:a4b8cb559ed8a8bb2a048092658b58d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8345e69747b85cff68497973fd4f2358"><td class="memItemLeft" align="right" valign="top"><a id="a8345e69747b85cff68497973fd4f2358"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>lthread_diag_ev</b> { <br />
&#160;&#160;<b>LT_DIAG_LTHREAD_CREATE</b>, 
<b>LT_DIAG_LTHREAD_EXIT</b>, 
<b>LT_DIAG_LTHREAD_JOIN</b>, 
<b>LT_DIAG_LTHREAD_CANCEL</b>, 
<br />
&#160;&#160;<b>LT_DIAG_LTHREAD_DETACH</b>, 
<b>LT_DIAG_LTHREAD_FREE</b>, 
<b>LT_DIAG_LTHREAD_SUSPENDED</b>, 
<b>LT_DIAG_LTHREAD_YIELD</b>, 
<br />
&#160;&#160;<b>LT_DIAG_LTHREAD_RESCHEDULED</b>, 
<b>LT_DIAG_LTHREAD_SLEEP</b>, 
<b>LT_DIAG_LTHREAD_RESUMED</b>, 
<b>LT_DIAG_LTHREAD_AFFINITY</b>, 
<br />
&#160;&#160;<b>LT_DIAG_LTHREAD_TMR_START</b>, 
<b>LT_DIAG_LTHREAD_TMR_DELETE</b>, 
<b>LT_DIAG_LTHREAD_TMR_EXPIRED</b>, 
<b>LT_DIAG_COND_CREATE</b>, 
<br />
&#160;&#160;<b>LT_DIAG_COND_DESTROY</b>, 
<b>LT_DIAG_COND_WAIT</b>, 
<b>LT_DIAG_COND_SIGNAL</b>, 
<b>LT_DIAG_COND_BROADCAST</b>, 
<br />
&#160;&#160;<b>LT_DIAG_MUTEX_CREATE</b>, 
<b>LT_DIAG_MUTEX_DESTROY</b>, 
<b>LT_DIAG_MUTEX_LOCK</b>, 
<b>LT_DIAG_MUTEX_TRYLOCK</b>, 
<br />
&#160;&#160;<b>LT_DIAG_MUTEX_BLOCKED</b>, 
<b>LT_DIAG_MUTEX_UNLOCKED</b>, 
<b>LT_DIAG_SCHED_CREATE</b>, 
<b>LT_DIAG_SCHED_SHUTDOWN</b>, 
<br />
&#160;&#160;<b>LT_DIAG_EVENT_MAX</b>
<br />
 }</td></tr>
<tr class="separator:a8345e69747b85cff68497973fd4f2358"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac6f814e3e915d921a8980f2f0bbd35e7"><td class="memItemLeft" align="right" valign="top"><a id="ac6f814e3e915d921a8980f2f0bbd35e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>lthread_diagnostic_enable</b> (diag_callback cb, uint64_t diag_mask)</td></tr>
<tr class="separator:ac6f814e3e915d921a8980f2f0bbd35e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e9d9e32085c08f6e435e472f6bf5c0"><td class="memItemLeft" align="right" valign="top"><a id="a13e9d9e32085c08f6e435e472f6bf5c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>lthread_diagnostic_set_mask</b> (uint64_t mask)</td></tr>
<tr class="separator:a13e9d9e32085c08f6e435e472f6bf5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad866ecc86b53cf464da57ba48941a780"><td class="memItemLeft" align="right" valign="top"><a id="ad866ecc86b53cf464da57ba48941a780"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>lthread_sched_stats_display</b> (void)</td></tr>
<tr class="separator:ad866ecc86b53cf464da57ba48941a780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb003947dae1dae0aa7c47b99d42593"><td class="memItemLeft" align="right" valign="top"><a id="aedb003947dae1dae0aa7c47b99d42593"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>lthread_cond_diag_ref</b> (struct <a class="el" href="structlthread__cond.html">lthread_cond</a> *c)</td></tr>
<tr class="separator:aedb003947dae1dae0aa7c47b99d42593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7f5ae805c5d4150ba2146ab53ed7ed"><td class="memItemLeft" align="right" valign="top"><a id="a7f7f5ae805c5d4150ba2146ab53ed7ed"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>lthread_mutex_diag_ref</b> (struct <a class="el" href="structlthread__mutex.html">lthread_mutex</a> *m)</td></tr>
<tr class="separator:a7f7f5ae805c5d4150ba2146ab53ed7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>lthread diagnostic interface</p>
<p>If enabled via configuration file option ( tbd ) the lthread subsystem can generate selected trace information, either RTE_LOG (INFO) messages, or else invoke a user supplied callback function when any of the events listed below occur.</p>
<p>Reporting of events can be selectively masked, the bit position in the mask is determined by the corresponding event identifier listed below.</p>
<p>Diagnostics are enabled by registering the callback function and mask using the API lthread_diagnostic_enable().</p>
<p>Various interesting parameters are passed to the callback, including the time in cpu clks, the lthread id, the diagnostic event id, a user ref value, event text string, object being traced, and two context dependent parameters (p1 and p2). The meaning of the two parameters p1 and p2 depends on the specific event.</p>
<p>The events LT_DIAG_LTHREAD_CREATE, LT_DIAG_MUTEX_CREATE and LT_DIAG_COND_CREATE are implicitly enabled if the event mask includes any of the LT_DIAG_LTHREAD_XXX, LT_DIAG_MUTEX_XXX or LT_DIAG_COND_XXX events respectively.</p>
<p>These create events may also be included in the mask discreetly if it is desired to monitor only create events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The time in cpu clks at which the event occurred</td></tr>
    <tr><td class="paramname">lthread</td><td>The current lthread</td></tr>
    <tr><td class="paramname">diag_event</td><td>The diagnostic event id (bit position in the mask)</td></tr>
    <tr><td class="paramname">diag_ref</td><td>For LT_DIAG_LTHREAD_CREATE, LT_DIAG_MUTEX_CREATE or LT_DIAG_COND_CREATE this parameter is not used and set to 0. All other events diag_ref contains the user ref value returned by the callback function when lthread is created.</td></tr>
  </table>
  </dd>
</dl>
<p>The diag_ref values assigned to mutex and cond var can be retrieved using the APIs lthread_mutex_diag_ref(), and lthread_cond_diag_ref() respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>see below</td></tr>
    <tr><td class="paramname">p1</td><td>see below</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For LT_DIAG_LTHREAD_CREATE, LT_DIAG_MUTEX_CREATE or LT_DIAG_COND_CREATE expects a user diagnostic ref value that will be saved in the lthread, mutex or cond var.</dd></dl>
<p>For all other events return value is ignored.</p>
<p>LT_DIAG_SCHED_CREATE - Invoked when a scheduler is created p1 = the scheduler that was created p2 = not used return value will be ignored</p>
<p>LT_DIAG_SCHED_SHUTDOWN - Invoked when a shutdown request is received p1 = the scheduler to be shutdown p2 = not used return value will be ignored</p>
<p>LT_DIAG_LTHREAD_CREATE - Invoked when a thread is created p1 = the lthread that was created p2 = not used return value will be stored in the lthread</p>
<p>LT_DIAG_LTHREAD_EXIT - Invoked when a lthread exits p2 = 0 if the thread was already joined p2 = 1 if the thread was not already joined return val ignored</p>
<p>LT_DIAG_LTHREAD_JOIN - Invoked when a lthread exits p1 = the lthread that is being joined p2 = 0 if the thread was already exited p2 = 1 if the thread was not already exited return val ignored</p>
<p>LT_DIAG_LTHREAD_CANCELLED - Invoked when an lthread is cancelled p1 = not used p2 = not used return val ignored</p>
<p>LT_DIAG_LTHREAD_DETACH - Invoked when an lthread is detached p1 = not used p2 = not used return val ignored</p>
<p>LT_DIAG_LTHREAD_FREE - Invoked when an lthread is freed p1 = not used p2 = not used return val ignored</p>
<p>LT_DIAG_LTHREAD_SUSPENDED - Invoked when an lthread is suspended p1 = not used p2 = not used return val ignored</p>
<p>LT_DIAG_LTHREAD_YIELD - Invoked when an lthread explicitly yields p1 = not used p2 = not used return val ignored</p>
<p>LT_DIAG_LTHREAD_RESCHEDULED - Invoked when an lthread is rescheduled p1 = not used p2 = not used return val ignored</p>
<p>LT_DIAG_LTHREAD_RESUMED - Invoked when an lthread is resumed p1 = not used p2 = not used return val ignored</p>
<p>LT_DIAG_LTHREAD_AFFINITY - Invoked when an lthread is affinitised p1 = the destination lcore_id p2 = not used return val ignored</p>
<p>LT_DIAG_LTHREAD_TMR_START - Invoked when an lthread starts a timer p1 = address of timer node p2 = the timeout value return val ignored</p>
<p>LT_DIAG_LTHREAD_TMR_DELETE - Invoked when an lthread deletes a timer p1 = address of the timer node p2 = 0 the timer and the was successfully deleted p2 = not usee return val ignored</p>
<p>LT_DIAG_LTHREAD_TMR_EXPIRED - Invoked when an lthread timer expires p1 = address of scheduler the timer expired on p2 = the thread associated with the timer return val ignored</p>
<p>LT_DIAG_COND_CREATE - Invoked when a condition variable is created p1 = address of cond var that was created p2 = not used return diag ref value will be stored in the condition variable</p>
<p>LT_DIAG_COND_DESTROY - Invoked when a condition variable is destroyed p1 = not used p2 = not used return val ignored</p>
<p>LT_DIAG_COND_WAIT - Invoked when an lthread waits on a cond var p1 = the address of the condition variable p2 = not used return val ignored</p>
<p>LT_DIAG_COND_SIGNAL - Invoked when an lthread signals a cond var p1 = the address of the cond var p2 = the lthread that was signalled, or error code return val ignored</p>
<p>LT_DIAG_COND_BROADCAST - Invoked when an lthread broadcasts a cond var p1 = the address of the condition variable p2 = the <a class="el" href="structlthread.html">lthread(s)</a> that are signalled, or error code</p>
<p>LT_DIAG_MUTEX_CREATE - Invoked when a mutex is created p1 = address of muex p2 = not used return diag ref value will be stored in the mutex variable</p>
<p>LT_DIAG_MUTEX_DESTROY - Invoked when a mutex is destroyed p1 = address of mutex p2 = not used return val ignored</p>
<p>LT_DIAG_MUTEX_LOCK - Invoked when a mutex lock is obtained p1 = address of mutex p2 = function return value return val ignored</p>
<p>LT_DIAG_MUTEX_BLOCKED - Invoked when an lthread blocks on a mutex p1 = address of mutex p2 = function return value return val ignored</p>
<p>LT_DIAG_MUTEX_TRYLOCK - Invoked when a mutex try lock is attempted p1 = address of mutex p2 = the function return value return val ignored</p>
<p>LT_DIAG_MUTEX_UNLOCKED - Invoked when a mutex is unlocked p1 = address of mutex p2 = the thread that was unlocked, or error code return val ignored </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
