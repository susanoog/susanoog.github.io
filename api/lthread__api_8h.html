<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Susanow: /home/slank/git/susanow/lthread/lthread_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Susanow
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_dfefae42a4cf55ba0761ace7a8746e62.html">susanow</a></li><li class="navelem"><a class="el" href="dir_a03b4f5d9147e1842fb1c504fc389932.html">lthread</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">lthread_api.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;sys/socket.h&gt;</code><br />
<code>#include &lt;fcntl.h&gt;</code><br />
<code>#include &lt;netinet/in.h&gt;</code><br />
<code>#include &lt;rte_cycles.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for lthread_api.h:</div>
<div class="dyncontent">
<div class="center"><img src="lthread__api_8h__incl.png" border="0" usemap="#_2home_2slank_2git_2susanow_2lthread_2lthread__api_8h" alt=""/></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="lthread__api_8h__dep__incl.png" border="0" usemap="#_2home_2slank_2git_2susanow_2lthread_2lthread__api_8hdep" alt=""/></div>
<map name="_2home_2slank_2git_2susanow_2lthread_2lthread__api_8hdep" id="_2home_2slank_2git_2susanow_2lthread_2lthread__api_8hdep">
<area shape="rect" id="node2" href="lthread_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread.h" alt="" coords="173,184,356,225"/>
<area shape="rect" id="node3" href="lthread__int_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_int.h" alt="" coords="584,273,766,315"/>
<area shape="rect" id="node11" href="lthread__diag_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_diag.h" alt="" coords="353,95,536,136"/>
<area shape="rect" id="node12" href="lthread__tls_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_tls.h" alt="" coords="584,184,766,225"/>
<area shape="rect" id="node6" href="lthread__queue_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_queue.h" alt="" coords="301,452,492,493"/>
<area shape="rect" id="node4" href="lthread__timer_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_timer.h" alt="" coords="625,720,816,761"/>
<area shape="rect" id="node5" href="lthread__sched_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_sched.h" alt="" coords="529,631,720,672"/>
<area shape="rect" id="node7" href="lthread__objcache_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_objcache.h" alt="" coords="519,541,730,583"/>
<area shape="rect" id="node10" href="lthread__pool_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_pool.h" alt="" coords="353,363,536,404"/>
<area shape="rect" id="node8" href="lthread__mutex_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_mutex.h" alt="" coords="253,541,444,583"/>
<area shape="rect" id="node9" href="lthread__cond_8h_source.html" title="/home/slank/git/susanow\l/lthread/lthread_cond.h" alt="" coords="46,541,229,583"/>
</map>
</div>
</div>
<p><a href="lthread__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab2099583333d19ae06bf0b526f9ec7dc"><td class="memItemLeft" align="right" valign="top"><a id="ab2099583333d19ae06bf0b526f9ec7dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LTHREAD_MAX_STACK_SIZE</b>&#160;&#160;&#160;(1024*64)</td></tr>
<tr class="separator:ab2099583333d19ae06bf0b526f9ec7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8ecf13a27e836e273d4ffbe7609413"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#aaa8ecf13a27e836e273d4ffbe7609413">LTHREAD_MAX_KEYS</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:aaa8ecf13a27e836e273d4ffbe7609413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the maximum number of TLS keys that can be created.  <a href="#aaa8ecf13a27e836e273d4ffbe7609413">More...</a><br /></td></tr>
<tr class="separator:aaa8ecf13a27e836e273d4ffbe7609413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee41d82bafaddbcbb286e799d18897bf"><td class="memItemLeft" align="right" valign="top"><a id="aee41d82bafaddbcbb286e799d18897bf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#aee41d82bafaddbcbb286e799d18897bf">LTHREAD_DESTRUCTOR_ITERATIONS</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:aee41d82bafaddbcbb286e799d18897bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the maximum number of attempts to destroy an lthread's TLS data on thread exit. <br /></td></tr>
<tr class="separator:aee41d82bafaddbcbb286e799d18897bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf673bd479eb5b1b8edf93583556d194"><td class="memItemLeft" align="right" valign="top"><a id="aaf673bd479eb5b1b8edf93583556d194"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#aaf673bd479eb5b1b8edf93583556d194">LTHREAD_MAX_LCORES</a>&#160;&#160;&#160;RTE_MAX_LCORE</td></tr>
<tr class="memdesc:aaf673bd479eb5b1b8edf93583556d194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the maximum number of lcores that will support lthreads. <br /></td></tr>
<tr class="separator:aaf673bd479eb5b1b8edf93583556d194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929e063215dabd2dea13f5f113f08394"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a929e063215dabd2dea13f5f113f08394">LTHREAD_PREALLOC</a>&#160;&#160;&#160;100</td></tr>
<tr class="memdesc:a929e063215dabd2dea13f5f113f08394"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many lthread objects to pre-allocate as the system grows applies to lthreads + stacks, TLS, mutexs, cond vars.  <a href="#a929e063215dabd2dea13f5f113f08394">More...</a><br /></td></tr>
<tr class="separator:a929e063215dabd2dea13f5f113f08394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f73287f8c24a0744b118dd40bf1ec4"><td class="memItemLeft" align="right" valign="top"><a id="a09f73287f8c24a0744b118dd40bf1ec4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RTE_DEFINE_PER_LTHREAD</b>(type,  name)&#160;&#160;&#160;__typeof__(type)__attribute((section(&quot;per_lt&quot;))) per_lt_##name</td></tr>
<tr class="separator:a09f73287f8c24a0744b118dd40bf1ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3de6384e8a0bb44cabf7bb7633b878"><td class="memItemLeft" align="right" valign="top"><a id="a2c3de6384e8a0bb44cabf7bb7633b878"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a2c3de6384e8a0bb44cabf7bb7633b878">RTE_DECLARE_PER_LTHREAD</a>(type,  name)&#160;&#160;&#160;extern __typeof__(type)__attribute((section(&quot;per_lt&quot;))) per_lt_##name</td></tr>
<tr class="memdesc:a2c3de6384e8a0bb44cabf7bb7633b878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to declare an extern per lthread variable "var" of type "type". <br /></td></tr>
<tr class="separator:a2c3de6384e8a0bb44cabf7bb7633b878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2c8485a38a4ed88a4ddcfefd06b406"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a4c2c8485a38a4ed88a4ddcfefd06b406">RTE_PER_LTHREAD</a>(name)</td></tr>
<tr class="memdesc:a4c2c8485a38a4ed88a4ddcfefd06b406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write the per-lcore variable value.  <a href="#a4c2c8485a38a4ed88a4ddcfefd06b406">More...</a><br /></td></tr>
<tr class="separator:a4c2c8485a38a4ed88a4ddcfefd06b406"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3726e769eec4d7cc1b7425758d904e22"><td class="memItemLeft" align="right" valign="top"><a id="a3726e769eec4d7cc1b7425758d904e22"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>lthread_func_t</b>) (void *)</td></tr>
<tr class="separator:a3726e769eec4d7cc1b7425758d904e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460acafbf7a33b06fb4c1dcce9e40c9a"><td class="memItemLeft" align="right" valign="top"><a id="a460acafbf7a33b06fb4c1dcce9e40c9a"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tls_destructor_func</b>) (void *)</td></tr>
<tr class="separator:a460acafbf7a33b06fb4c1dcce9e40c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae1a9eb185d9bb5c8275e35c07948b144"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#ae1a9eb185d9bb5c8275e35c07948b144">lthread_num_schedulers_set</a> (int num)</td></tr>
<tr class="memdesc:ae1a9eb185d9bb5c8275e35c07948b144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of schedulers in the system.  <a href="#ae1a9eb185d9bb5c8275e35c07948b144">More...</a><br /></td></tr>
<tr class="separator:ae1a9eb185d9bb5c8275e35c07948b144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d408e13286473e0b86783784fac1ae4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a0d408e13286473e0b86783784fac1ae4">lthread_active_schedulers</a> (void)</td></tr>
<tr class="memdesc:a0d408e13286473e0b86783784fac1ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of schedulers currently running.  <a href="#a0d408e13286473e0b86783784fac1ae4">More...</a><br /></td></tr>
<tr class="separator:a0d408e13286473e0b86783784fac1ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1289a65648e2b805ee472cf302449a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a1289a65648e2b805ee472cf302449a47">lthread_scheduler_shutdown</a> (unsigned lcore)</td></tr>
<tr class="memdesc:a1289a65648e2b805ee472cf302449a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown the specified scheduler.  <a href="#a1289a65648e2b805ee472cf302449a47">More...</a><br /></td></tr>
<tr class="separator:a1289a65648e2b805ee472cf302449a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69cb580350eda934d2753d61ae1289b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#ad69cb580350eda934d2753d61ae1289b">lthread_scheduler_shutdown_all</a> (void)</td></tr>
<tr class="memdesc:ad69cb580350eda934d2753d61ae1289b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown all schedulers.  <a href="#ad69cb580350eda934d2753d61ae1289b">More...</a><br /></td></tr>
<tr class="separator:ad69cb580350eda934d2753d61ae1289b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a080a2c42b92e0a35cbf0870a79c250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a1a080a2c42b92e0a35cbf0870a79c250">lthread_run</a> (void)</td></tr>
<tr class="memdesc:a1a080a2c42b92e0a35cbf0870a79c250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the lthread scheduler.  <a href="#a1a080a2c42b92e0a35cbf0870a79c250">More...</a><br /></td></tr>
<tr class="separator:a1a080a2c42b92e0a35cbf0870a79c250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbde9d42aa055bf78b0894a46b97d05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a9fbde9d42aa055bf78b0894a46b97d05">lthread_create</a> (struct <a class="el" href="structlthread.html">lthread</a> **new_lt, int lcore, lthread_func_t func, void *arg)</td></tr>
<tr class="memdesc:a9fbde9d42aa055bf78b0894a46b97d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an lthread.  <a href="#a9fbde9d42aa055bf78b0894a46b97d05">More...</a><br /></td></tr>
<tr class="separator:a9fbde9d42aa055bf78b0894a46b97d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d82e8be8f91d7827821cffca9307c79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a0d82e8be8f91d7827821cffca9307c79">lthread_cancel</a> (struct <a class="el" href="structlthread.html">lthread</a> *lt)</td></tr>
<tr class="memdesc:a0d82e8be8f91d7827821cffca9307c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel an lthread.  <a href="#a0d82e8be8f91d7827821cffca9307c79">More...</a><br /></td></tr>
<tr class="separator:a0d82e8be8f91d7827821cffca9307c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93da252572a8bbcf09ec8ed6f30fc1eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a93da252572a8bbcf09ec8ed6f30fc1eb">lthread_join</a> (struct <a class="el" href="structlthread.html">lthread</a> *lt, void **ptr)</td></tr>
<tr class="memdesc:a93da252572a8bbcf09ec8ed6f30fc1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join an lthread.  <a href="#a93da252572a8bbcf09ec8ed6f30fc1eb">More...</a><br /></td></tr>
<tr class="separator:a93da252572a8bbcf09ec8ed6f30fc1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722498ebbcabd31831e4df7ceb4c98d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a722498ebbcabd31831e4df7ceb4c98d0">lthread_detach</a> (void)</td></tr>
<tr class="memdesc:a722498ebbcabd31831e4df7ceb4c98d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach an lthread.  <a href="#a722498ebbcabd31831e4df7ceb4c98d0">More...</a><br /></td></tr>
<tr class="separator:a722498ebbcabd31831e4df7ceb4c98d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbead5cd48f21e019be6a37b81031fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#aecbead5cd48f21e019be6a37b81031fb">lthread_exit</a> (void *val)</td></tr>
<tr class="memdesc:aecbead5cd48f21e019be6a37b81031fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit an lthread.  <a href="#aecbead5cd48f21e019be6a37b81031fb">More...</a><br /></td></tr>
<tr class="separator:aecbead5cd48f21e019be6a37b81031fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebcb5c57b7930ef2658bf9c497c054b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a6ebcb5c57b7930ef2658bf9c497c054b">lthread_sleep</a> (uint64_t nsecs)</td></tr>
<tr class="memdesc:a6ebcb5c57b7930ef2658bf9c497c054b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause the current lthread to sleep for n nanoseconds.  <a href="#a6ebcb5c57b7930ef2658bf9c497c054b">More...</a><br /></td></tr>
<tr class="separator:a6ebcb5c57b7930ef2658bf9c497c054b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acc3b3330ec5c4e9682d4f2fef15d63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a7acc3b3330ec5c4e9682d4f2fef15d63">lthread_sleep_clks</a> (uint64_t clks)</td></tr>
<tr class="memdesc:a7acc3b3330ec5c4e9682d4f2fef15d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause the current lthread to sleep for n cpu clock ticks.  <a href="#a7acc3b3330ec5c4e9682d4f2fef15d63">More...</a><br /></td></tr>
<tr class="separator:a7acc3b3330ec5c4e9682d4f2fef15d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92521ac051ed98eaabeb86daba988de9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a92521ac051ed98eaabeb86daba988de9">lthread_yield</a> (void)</td></tr>
<tr class="memdesc:a92521ac051ed98eaabeb86daba988de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the current lthread.  <a href="#a92521ac051ed98eaabeb86daba988de9">More...</a><br /></td></tr>
<tr class="separator:a92521ac051ed98eaabeb86daba988de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58856cb3156fd41e1c6ce1122cdb2cab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a58856cb3156fd41e1c6ce1122cdb2cab">lthread_set_affinity</a> (unsigned lcore)</td></tr>
<tr class="memdesc:a58856cb3156fd41e1c6ce1122cdb2cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate the current thread to another scheduler.  <a href="#a58856cb3156fd41e1c6ce1122cdb2cab">More...</a><br /></td></tr>
<tr class="separator:a58856cb3156fd41e1c6ce1122cdb2cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cbb351e5c9a387f69ddfd2dd0da8f7"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlthread.html">lthread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a30cbb351e5c9a387f69ddfd2dd0da8f7">lthread_current</a> (void)</td></tr>
<tr class="memdesc:a30cbb351e5c9a387f69ddfd2dd0da8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current lthread.  <a href="#a30cbb351e5c9a387f69ddfd2dd0da8f7">More...</a><br /></td></tr>
<tr class="separator:a30cbb351e5c9a387f69ddfd2dd0da8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a265712b883d26d6557af822a9d30e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a7a265712b883d26d6557af822a9d30e9">lthread_set_data</a> (void *data)</td></tr>
<tr class="memdesc:a7a265712b883d26d6557af822a9d30e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate user data with an lthread.  <a href="#a7a265712b883d26d6557af822a9d30e9">More...</a><br /></td></tr>
<tr class="separator:a7a265712b883d26d6557af822a9d30e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2587090a89756fbb9a2db0d9dc869b4b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a2587090a89756fbb9a2db0d9dc869b4b">lthread_get_data</a> (void)</td></tr>
<tr class="memdesc:a2587090a89756fbb9a2db0d9dc869b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get user data for the current lthread.  <a href="#a2587090a89756fbb9a2db0d9dc869b4b">More...</a><br /></td></tr>
<tr class="separator:a2587090a89756fbb9a2db0d9dc869b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cc63807dae84772dfecec041911c22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#aa7cc63807dae84772dfecec041911c22">lthread_key_create</a> (unsigned int *key, tls_destructor_func destructor)</td></tr>
<tr class="memdesc:aa7cc63807dae84772dfecec041911c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a key for lthread TLS.  <a href="#aa7cc63807dae84772dfecec041911c22">More...</a><br /></td></tr>
<tr class="separator:aa7cc63807dae84772dfecec041911c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2689947bb83a330aff7e78d439c378"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#aef2689947bb83a330aff7e78d439c378">lthread_key_delete</a> (unsigned int key)</td></tr>
<tr class="memdesc:aef2689947bb83a330aff7e78d439c378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete key for lthread TLS.  <a href="#aef2689947bb83a330aff7e78d439c378">More...</a><br /></td></tr>
<tr class="separator:aef2689947bb83a330aff7e78d439c378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2fb7a60708c6b65a322292466f835d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#aea2fb7a60708c6b65a322292466f835d">lthread_getspecific</a> (unsigned int key)</td></tr>
<tr class="memdesc:aea2fb7a60708c6b65a322292466f835d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lthread TLS.  <a href="#aea2fb7a60708c6b65a322292466f835d">More...</a><br /></td></tr>
<tr class="separator:aea2fb7a60708c6b65a322292466f835d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c993ca01086ed9b9615dc73e1036285"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a1c993ca01086ed9b9615dc73e1036285">lthread_setspecific</a> (unsigned int key, const void *value)</td></tr>
<tr class="memdesc:a1c993ca01086ed9b9615dc73e1036285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set lthread TLS.  <a href="#a1c993ca01086ed9b9615dc73e1036285">More...</a><br /></td></tr>
<tr class="separator:a1c993ca01086ed9b9615dc73e1036285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07d3cba5685e6cd01c71f22e42a6f31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#af07d3cba5685e6cd01c71f22e42a6f31">lthread_mutex_init</a> (char *name, struct <a class="el" href="structlthread__mutex.html">lthread_mutex</a> **mutex, const struct lthread_mutexattr *attr)</td></tr>
<tr class="memdesc:af07d3cba5685e6cd01c71f22e42a6f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a mutex.  <a href="#af07d3cba5685e6cd01c71f22e42a6f31">More...</a><br /></td></tr>
<tr class="separator:af07d3cba5685e6cd01c71f22e42a6f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332448263997db116a423363b56dc049"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a332448263997db116a423363b56dc049">lthread_mutex_destroy</a> (struct <a class="el" href="structlthread__mutex.html">lthread_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a332448263997db116a423363b56dc049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a mutex.  <a href="#a332448263997db116a423363b56dc049">More...</a><br /></td></tr>
<tr class="separator:a332448263997db116a423363b56dc049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a66e3e0cb55e8f9ba54498e4c859ef6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a0a66e3e0cb55e8f9ba54498e4c859ef6">lthread_mutex_lock</a> (struct <a class="el" href="structlthread__mutex.html">lthread_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a0a66e3e0cb55e8f9ba54498e4c859ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a mutex.  <a href="#a0a66e3e0cb55e8f9ba54498e4c859ef6">More...</a><br /></td></tr>
<tr class="separator:a0a66e3e0cb55e8f9ba54498e4c859ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c42adb8e2bc9862ded32cef1b2b8c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#aa3c42adb8e2bc9862ded32cef1b2b8c2">lthread_mutex_trylock</a> (struct <a class="el" href="structlthread__mutex.html">lthread_mutex</a> *mutex)</td></tr>
<tr class="memdesc:aa3c42adb8e2bc9862ded32cef1b2b8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock a mutex.  <a href="#aa3c42adb8e2bc9862ded32cef1b2b8c2">More...</a><br /></td></tr>
<tr class="separator:aa3c42adb8e2bc9862ded32cef1b2b8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9dc7cc0c0cfe58ac1babf3e536f6c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a2c9dc7cc0c0cfe58ac1babf3e536f6c7">lthread_mutex_unlock</a> (struct <a class="el" href="structlthread__mutex.html">lthread_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a2c9dc7cc0c0cfe58ac1babf3e536f6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a mutex.  <a href="#a2c9dc7cc0c0cfe58ac1babf3e536f6c7">More...</a><br /></td></tr>
<tr class="separator:a2c9dc7cc0c0cfe58ac1babf3e536f6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0146132f8950c99aa15cb60b022405b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a0146132f8950c99aa15cb60b022405b1">lthread_cond_init</a> (char *name, struct <a class="el" href="structlthread__cond.html">lthread_cond</a> **c, const struct lthread_condattr *attr)</td></tr>
<tr class="memdesc:a0146132f8950c99aa15cb60b022405b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a condition variable.  <a href="#a0146132f8950c99aa15cb60b022405b1">More...</a><br /></td></tr>
<tr class="separator:a0146132f8950c99aa15cb60b022405b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfca37bcc1bd2d18dda5f025d99bd3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a5bfca37bcc1bd2d18dda5f025d99bd3e">lthread_cond_destroy</a> (struct <a class="el" href="structlthread__cond.html">lthread_cond</a> *cond)</td></tr>
<tr class="memdesc:a5bfca37bcc1bd2d18dda5f025d99bd3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a condition variable.  <a href="#a5bfca37bcc1bd2d18dda5f025d99bd3e">More...</a><br /></td></tr>
<tr class="separator:a5bfca37bcc1bd2d18dda5f025d99bd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfc012481495f6567b4c1e079c45914"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#aabfc012481495f6567b4c1e079c45914">lthread_cond_wait</a> (struct <a class="el" href="structlthread__cond.html">lthread_cond</a> *c, uint64_t reserved)</td></tr>
<tr class="memdesc:aabfc012481495f6567b4c1e079c45914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a condition variable.  <a href="#aabfc012481495f6567b4c1e079c45914">More...</a><br /></td></tr>
<tr class="separator:aabfc012481495f6567b4c1e079c45914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6a116207558ae6b924252415a229a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a5b6a116207558ae6b924252415a229a1">lthread_cond_signal</a> (struct <a class="el" href="structlthread__cond.html">lthread_cond</a> *c)</td></tr>
<tr class="memdesc:a5b6a116207558ae6b924252415a229a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a condition variable.  <a href="#a5b6a116207558ae6b924252415a229a1">More...</a><br /></td></tr>
<tr class="separator:a5b6a116207558ae6b924252415a229a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce7115acf32ccff89233ce49837ab08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#a9ce7115acf32ccff89233ce49837ab08">lthread_cond_broadcast</a> (struct <a class="el" href="structlthread__cond.html">lthread_cond</a> *c)</td></tr>
<tr class="memdesc:a9ce7115acf32ccff89233ce49837ab08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast a condition variable.  <a href="#a9ce7115acf32ccff89233ce49837ab08">More...</a><br /></td></tr>
<tr class="separator:a9ce7115acf32ccff89233ce49837ab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae32ee1343ae4af64262de55a4c20f634"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lthread__api_8h.html#ae32ee1343ae4af64262de55a4c20f634">__start_per_lt</a></td></tr>
<tr class="memdesc:ae32ee1343ae4af64262de55a4c20f634"><td class="mdescLeft">&#160;</td><td class="mdescRight">The macros below provide an alternative mechanism to access lthread local storage.  <a href="#ae32ee1343ae4af64262de55a4c20f634">More...</a><br /></td></tr>
<tr class="separator:ae32ee1343ae4af64262de55a4c20f634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed40a441acf6036d9b92147884404b32"><td class="memItemLeft" align="right" valign="top"><a id="aed40a441acf6036d9b92147884404b32"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>__stop_per_lt</b></td></tr>
<tr class="separator:aed40a441acf6036d9b92147884404b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>This file contains the public API for the L-thread subsystem</p>
<p>The L_thread subsystem provides a simple cooperative scheduler to enable arbitrary functions to run as cooperative threads within a single P-thread.</p>
<p>The subsystem provides a P-thread like API that is intended to assist in reuse of legacy code written for POSIX p_threads.</p>
<p>The L-thread subsystem relies on cooperative multitasking, as such an L-thread must possess frequent rescheduling points. Often these rescheduling points are provided transparently when the application invokes an L-thread API.</p>
<p>In some applications it is possible that the program may enter a loop the exit condition for which depends on the action of another thread or a response from hardware. In such a case it is necessary to yield the thread periodically in the loop body, to allow other threads an opportunity to run. This can be done by inserting a call to <a class="el" href="lthread__api_8h.html#a92521ac051ed98eaabeb86daba988de9" title="Yield the current lthread. ">lthread_yield()</a> or lthread_sleep(n) in the body of the loop.</p>
<p>If the application makes expensive / blocking system calls or does other work that would take an inordinate amount of time to complete, this will stall the cooperative scheduler resulting in very poor performance.</p>
<p>In such cases an L-thread can be migrated temporarily to another scheduler running in a different P-thread on another core. When the expensive or blocking operation is completed it can be migrated back to the original scheduler. In this way other threads can continue to run on the original scheduler and will be completely unaffected by the blocking behaviour. To migrate an L-thread to another scheduler the API <a class="el" href="lthread__api_8h.html#a58856cb3156fd41e1c6ce1122cdb2cab" title="Migrate the current thread to another scheduler. ">lthread_set_affinity()</a> is provided.</p>
<p>If L-threads that share data are running on the same core it is possible to design programs where mutual exclusion mechanisms to protect shared data can be avoided. This is due to the fact that the cooperative threads cannot preempt each other.</p>
<p>There are two cases where mutual exclusion mechanisms are necessary.</p>
<p>a) Where the L-threads sharing data are running on different cores. b) Where code must yield while updating data shared with another thread.</p>
<p>The L-thread subsystem provides a set of mutex APIs to help with such scenarios, however excessive reliance on on these will impact performance and is best avoided if possible.</p>
<p>L-threads can synchronise using a fast condition variable implementation that supports signal and broadcast. An L-thread running on any core can wait on a condition.</p>
<p>L-threads can have L-thread local storage with an API modelled on either the P-thread get/set specific API or using PER_LTHREAD macros modelled on the RTE_PER_LCORE macros. Alternatively a simple user data pointer may be set and retrieved from a thread. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aaa8ecf13a27e836e273d4ffbe7609413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8ecf13a27e836e273d4ffbe7609413">&sect;&nbsp;</a></span>LTHREAD_MAX_KEYS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LTHREAD_MAX_KEYS&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the maximum number of TLS keys that can be created. </p>

</div>
</div>
<a id="a929e063215dabd2dea13f5f113f08394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929e063215dabd2dea13f5f113f08394">&sect;&nbsp;</a></span>LTHREAD_PREALLOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LTHREAD_PREALLOC&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many lthread objects to pre-allocate as the system grows applies to lthreads + stacks, TLS, mutexs, cond vars. </p>
<dl class="section see"><dt>See also</dt><dd>_lthread_alloc() </dd>
<dd>
_cond_alloc() </dd>
<dd>
_mutex_alloc() </dd></dl>

</div>
</div>
<a id="a4c2c8485a38a4ed88a4ddcfefd06b406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2c8485a38a4ed88a4ddcfefd06b406">&sect;&nbsp;</a></span>RTE_PER_LTHREAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_PER_LTHREAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((typeof(per_lt_##name) *)\</div><div class="line">((<span class="keywordtype">char</span> *)<a class="code" href="lthread__api_8h.html#a2587090a89756fbb9a2db0d9dc869b4b">lthread_get_data</a>() +\</div><div class="line">((<span class="keywordtype">char</span> *) &amp;per_lt_##name - &amp;<a class="code" href="lthread__api_8h.html#ae32ee1343ae4af64262de55a4c20f634">__start_per_lt</a>)))</div><div class="ttc" id="lthread__api_8h_html_a2587090a89756fbb9a2db0d9dc869b4b"><div class="ttname"><a href="lthread__api_8h.html#a2587090a89756fbb9a2db0d9dc869b4b">lthread_get_data</a></div><div class="ttdeci">void * lthread_get_data(void)</div><div class="ttdoc">Get user data for the current lthread. </div><div class="ttdef"><b>Definition:</b> lthread.c:308</div></div>
<div class="ttc" id="lthread__api_8h_html_ae32ee1343ae4af64262de55a4c20f634"><div class="ttname"><a href="lthread__api_8h.html#ae32ee1343ae4af64262de55a4c20f634">__start_per_lt</a></div><div class="ttdeci">char __start_per_lt</div><div class="ttdoc">The macros below provide an alternative mechanism to access lthread local storage. </div></div>
</div><!-- fragment -->
<p>Read/write the per-lcore variable value. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0d408e13286473e0b86783784fac1ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d408e13286473e0b86783784fac1ae4">&sect;&nbsp;</a></span>lthread_active_schedulers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_active_schedulers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of schedulers currently running. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of schedulers in the system </dd></dl>

</div>
</div>
<a id="a0d82e8be8f91d7827821cffca9307c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d82e8be8f91d7827821cffca9307c79">&sect;&nbsp;</a></span>lthread_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_cancel </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlthread.html">lthread</a> *&#160;</td>
          <td class="paramname"><em>lt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel an lthread. </p>
<p>Cancels an lthread and causes it to be terminated If the lthread is detached it will be freed immediately otherwise its resources will not be released until it is joined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_lt</td><td>Pointer to an lthread that will be cancelled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL thread was NULL </dd></dl>

</div>
</div>
<a id="a9ce7115acf32ccff89233ce49837ab08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce7115acf32ccff89233ce49837ab08">&sect;&nbsp;</a></span>lthread_cond_broadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_cond_broadcast </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlthread__cond.html">lthread_cond</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcast a condition variable. </p>
<p>The function unblocks all threads waiting for the condition variable cond. If no threads are waiting on cond, the rte_lthead_cond_broadcast() function has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to pointer to the condition variable to be signalled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 The condition was signalled ( Success ) EINVAL was not a an initialised condition variable </dd></dl>

</div>
</div>
<a id="a5bfca37bcc1bd2d18dda5f025d99bd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfca37bcc1bd2d18dda5f025d99bd3e">&sect;&nbsp;</a></span>lthread_cond_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_cond_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlthread__cond.html">lthread_cond</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a condition variable. </p>
<p>This function destroys a condition variable that was created with <a class="el" href="lthread__api_8h.html#a0146132f8950c99aa15cb60b022405b1" title="Initialize a condition variable. ">lthread_cond_init()</a> and releases its resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to pointer to the condition variable to be destroyed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Success EBUSY condition variable was still in use EINVAL was not an initialised condition variable </dd></dl>

</div>
</div>
<a id="a0146132f8950c99aa15cb60b022405b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0146132f8950c99aa15cb60b022405b1">&sect;&nbsp;</a></span>lthread_cond_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_cond_init </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlthread__cond.html">lthread_cond</a> **&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct lthread_condattr *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a condition variable. </p>
<p>This function initializes a condition variable.</p>
<p>Condition variables can be used to communicate changes in the state of data shared between threads.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lthread__api_8h.html#aabfc012481495f6567b4c1e079c45914" title="Wait on a condition variable. ">lthread_cond_wait()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to optional string describing the condition variable </td></tr>
    <tr><td class="paramname">c</td><td>Pointer to pointer to the condition variable to be initialized </td></tr>
    <tr><td class="paramname">attr</td><td>Pointer to optional attribute reserved for future use, currently ignored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL cond was not a valid pointer EAGAIN insufficient resources </dd></dl>

</div>
</div>
<a id="a5b6a116207558ae6b924252415a229a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6a116207558ae6b924252415a229a1">&sect;&nbsp;</a></span>lthread_cond_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_cond_signal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlthread__cond.html">lthread_cond</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal a condition variable. </p>
<p>The function unblocks one thread waiting for the condition variable cond. If no threads are waiting on cond, the rte_lthead_cond_signal() function has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to pointer to the condition variable to be signalled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 The condition was signalled ( Success ) EINVAL was not a an initialised condition variable </dd></dl>

</div>
</div>
<a id="aabfc012481495f6567b4c1e079c45914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfc012481495f6567b4c1e079c45914">&sect;&nbsp;</a></span>lthread_cond_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_cond_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlthread__cond.html">lthread_cond</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>reserved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on a condition variable. </p>
<p>The function blocks the current thread waiting on the condition variable specified by cond. The waiting thread unblocks only after another thread calls lthread_cond_signal, or lthread_cond_broadcast, specifying the same condition variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to pointer to the condition variable to be waited on</td></tr>
    <tr><td class="paramname">reserved</td><td>reserved for future use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 The condition was signalled ( Success ) EINVAL was not a an initialised condition variable </dd></dl>

</div>
</div>
<a id="a9fbde9d42aa055bf78b0894a46b97d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbde9d42aa055bf78b0894a46b97d05">&sect;&nbsp;</a></span>lthread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlthread.html">lthread</a> **&#160;</td>
          <td class="paramname"><em>new_lt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lcore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lthread_func_t&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an lthread. </p>
<p>Creates an lthread and places it in the ready queue on a particular lcore.</p>
<p>If no scheduler exists yet on the curret lcore then one is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_lt</td><td>Pointer to an lthread pointer that will be initialized </td></tr>
    <tr><td class="paramname">lcore</td><td>the lcore the thread should be started on or the current clore -1 the current lcore 0 - LTHREAD_MAX_LCORES any other lcore </td></tr>
    <tr><td class="paramname">lthread_func</td><td>Pointer to the function the for the thread to run </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer to args that will be passed to the thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EAGAIN no resources available EINVAL NULL thread or function pointer, or lcore_id out of range </dd></dl>

</div>
</div>
<a id="a30cbb351e5c9a387f69ddfd2dd0da8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cbb351e5c9a387f69ddfd2dd0da8f7">&sect;&nbsp;</a></span>lthread_current()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlthread.html">lthread</a>* lthread_current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current lthread. </p>
<p>Returns the current lthread</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the current lthread </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="lthread__api_8h_a30cbb351e5c9a387f69ddfd2dd0da8f7_cgraph.png" border="0" usemap="#lthread__api_8h_a30cbb351e5c9a387f69ddfd2dd0da8f7_cgraph" alt=""/></div>
<map name="lthread__api_8h_a30cbb351e5c9a387f69ddfd2dd0da8f7_cgraph" id="lthread__api_8h_a30cbb351e5c9a387f69ddfd2dd0da8f7_cgraph">
<area shape="rect" id="node2" href="lthread__api_8h.html#a722498ebbcabd31831e4df7ceb4c98d0" title="Detach an lthread. " alt="" coords="180,5,300,32"/>
</map>
</div>

</div>
</div>
<a id="a722498ebbcabd31831e4df7ceb4c98d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722498ebbcabd31831e4df7ceb4c98d0">&sect;&nbsp;</a></span>lthread_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lthread_detach </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach an lthread. </p>
<p>Detaches the current thread On exit a detached lthread will be freed immediately and will not wait to be joined. The default state for a thread is not detached.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="aecbead5cd48f21e019be6a37b81031fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbead5cd48f21e019be6a37b81031fb">&sect;&nbsp;</a></span>lthread_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lthread_exit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit an lthread. </p>
<p>Terminate the current thread, optionally return data. The data may be collected by <a class="el" href="lthread__api_8h.html#a93da252572a8bbcf09ec8ed6f30fc1eb" title="Join an lthread. ">lthread_join()</a></p>
<p>After calling this function the lthread will be suspended until it is joined. After it is joined then its resources will be freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to pointer to data to be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a2587090a89756fbb9a2db0d9dc869b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2587090a89756fbb9a2db0d9dc869b4b">&sect;&nbsp;</a></span>lthread_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lthread_get_data </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get user data for the current lthread. </p>
<p>This function returns a user data pointer for the current lthread The pointer must first be set with <a class="el" href="lthread__api_8h.html#a7a265712b883d26d6557af822a9d30e9" title="Associate user data with an lthread. ">lthread_set_data()</a> It is the users responsibility to allocate and free any data referenced by the user pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to user data </dd></dl>

</div>
</div>
<a id="aea2fb7a60708c6b65a322292466f835d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2fb7a60708c6b65a322292466f835d">&sect;&nbsp;</a></span>lthread_getspecific()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lthread_getspecific </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get lthread TLS. </p>
<p>This function is modelled on pthread_get_specific(). It returns the value currently bound to the specified key on behalf of the calling thread. Calling <a class="el" href="lthread__api_8h.html#aea2fb7a60708c6b65a322292466f835d" title="Get lthread TLS. ">lthread_getspecific()</a> with a key value not obtained from <a class="el" href="lthread__api_8h.html#aa7cc63807dae84772dfecec041911c22" title="Create a key for lthread TLS. ">lthread_key_create()</a> or after key has been deleted with <a class="el" href="lthread__api_8h.html#aef2689947bb83a330aff7e78d439c378" title="Delete key for lthread TLS. ">lthread_key_delete()</a> will result in undefined behaviour. <a class="el" href="lthread__api_8h.html#aea2fb7a60708c6b65a322292466f835d" title="Get lthread TLS. ">lthread_getspecific()</a> may be called from a thread-specific data destructor function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key for which data is requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the thread specific data associated with that key or NULL if no data has been set. </dd></dl>

</div>
</div>
<a id="a93da252572a8bbcf09ec8ed6f30fc1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93da252572a8bbcf09ec8ed6f30fc1eb">&sect;&nbsp;</a></span>lthread_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_join </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlthread.html">lthread</a> *&#160;</td>
          <td class="paramname"><em>lt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join an lthread. </p>
<p>Joins the current thread with the specified lthread, and waits for that thread to exit. Passes an optional pointer to collect returned data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lt</td><td>Pointer to the lthread to be joined </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to pointer to collect returned data</td></tr>
  </table>
  </dd>
</dl>
<p>0 * </p><dl class="section return"><dt>Returns</dt><dd>0 success EINVAL lthread could not be joined. </dd></dl>

</div>
</div>
<a id="aa7cc63807dae84772dfecec041911c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cc63807dae84772dfecec041911c22">&sect;&nbsp;</a></span>lthread_key_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_key_create </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tls_destructor_func&#160;</td>
          <td class="paramname"><em>destructor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a key for lthread TLS. </p>
<p>This function is modelled on pthread_key_create It creates a thread-specific data key visible to all lthreads on the current scheduler.</p>
<p>Key values may be used to locate thread-specific data. The same key value may be used by different threads, the values bound to the key by <a class="el" href="lthread__api_8h.html#a1c993ca01086ed9b9615dc73e1036285" title="Set lthread TLS. ">lthread_setspecific()</a> are maintained on a per-thread basis and persist for the life of the calling thread.</p>
<p>An optional destructor function may be associated with each key value. At thread exit, if a key value has a non-NULL destructor pointer, and the thread has a non-NULL value associated with the key, the function pointed to is called with the current associated value as its sole argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Pointer to the key to be created </td></tr>
    <tr><td class="paramname">destructor</td><td>Pointer to destructor function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL the key ptr was NULL EAGAIN no resources available </dd></dl>

</div>
</div>
<a id="aef2689947bb83a330aff7e78d439c378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2689947bb83a330aff7e78d439c378">&sect;&nbsp;</a></span>lthread_key_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_key_delete </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete key for lthread TLS. </p>
<p>This function is modelled on pthread_key_delete(). It deletes a thread-specific data key previously returned by <a class="el" href="lthread__api_8h.html#aa7cc63807dae84772dfecec041911c22" title="Create a key for lthread TLS. ">lthread_key_create()</a>. The thread-specific data values associated with the key need not be NULL at the time that lthread_key_delete is called. It is the responsibility of the application to free any application storage or perform any cleanup actions for data structures related to the deleted key. This cleanup can be done either before or after lthread_key_delete is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to be deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Success EINVAL the key was invalid </dd></dl>

</div>
</div>
<a id="a332448263997db116a423363b56dc049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332448263997db116a423363b56dc049">&sect;&nbsp;</a></span>lthread_mutex_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_mutex_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlthread__mutex.html">lthread_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a mutex. </p>
<p>This function destroys the specified mutex freeing its resources. The mutex must be unlocked before calling lthread_mutex_destroy.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lthread__api_8h.html#af07d3cba5685e6cd01c71f22e42a6f31" title="Initialize a mutex. ">lthread_mutex_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to pointer to the mutex to be initialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL mutex was not an initialized mutex EBUSY mutex was still in use </dd></dl>

</div>
</div>
<a id="af07d3cba5685e6cd01c71f22e42a6f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07d3cba5685e6cd01c71f22e42a6f31">&sect;&nbsp;</a></span>lthread_mutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_mutex_init </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlthread__mutex.html">lthread_mutex</a> **&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct lthread_mutexattr *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a mutex. </p>
<p>This function provides a mutual exclusion device, the need for which can normally be avoided in a cooperative multitasking environment. It is provided to aid porting of legacy code originally written for preemptive multitasking environments such as pthreads.</p>
<p>A mutex may be unlocked (not owned by any thread), or locked (owned by one thread).</p>
<p>A mutex can never be owned by more than one thread simultaneously. A thread attempting to lock a mutex that is already locked by another thread is suspended until the owning thread unlocks the mutex.</p>
<p><a class="el" href="lthread__api_8h.html#af07d3cba5685e6cd01c71f22e42a6f31" title="Initialize a mutex. ">lthread_mutex_init()</a> initializes the mutex object pointed to by mutex Optional mutex attributes specified in mutexattr, are reserved for future use and are currently ignored.</p>
<p>If a thread calls <a class="el" href="lthread__api_8h.html#a0a66e3e0cb55e8f9ba54498e4c859ef6" title="Lock a mutex. ">lthread_mutex_lock()</a> on the mutex, then if the mutex is currently unlocked, it becomes locked and owned by the calling thread, and lthread_mutex_lock returns immediately. If the mutex is already locked by another thread, lthread_mutex_lock suspends the calling thread until the mutex is unlocked.</p>
<p>lthread_mutex_trylock behaves identically to rte_thread_mutex_lock, except that it does not block the calling thread if the mutex is already locked by another thread.</p>
<p><a class="el" href="lthread__api_8h.html#a2c9dc7cc0c0cfe58ac1babf3e536f6c7" title="Unlock a mutex. ">lthread_mutex_unlock()</a> unlocks the specified mutex. The mutex is assumed to be locked and owned by the calling thread.</p>
<p><a class="el" href="lthread__api_8h.html#a332448263997db116a423363b56dc049" title="Destroy a mutex. ">lthread_mutex_destroy()</a> destroys a mutex object, freeing its resources. The mutex must be unlocked with nothing blocked on it before calling lthread_mutex_destroy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Optional pointer to string describing the mutex </td></tr>
    <tr><td class="paramname">mutex</td><td>Pointer to pointer to the mutex to be initialized </td></tr>
    <tr><td class="paramname">attribute</td><td>Pointer to attribute - unused reserved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL mutex was not a valid pointer EAGAIN insufficient resources </dd></dl>

</div>
</div>
<a id="a0a66e3e0cb55e8f9ba54498e4c859ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a66e3e0cb55e8f9ba54498e4c859ef6">&sect;&nbsp;</a></span>lthread_mutex_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlthread__mutex.html">lthread_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a mutex. </p>
<p>This function attempts to lock a mutex. If a thread calls <a class="el" href="lthread__api_8h.html#a0a66e3e0cb55e8f9ba54498e4c859ef6" title="Lock a mutex. ">lthread_mutex_lock()</a> on the mutex, then if the mutex is currently unlocked, it becomes locked and owned by the calling thread, and lthread_mutex_lock returns immediately. If the mutex is already locked by another thread, lthread_mutex_lock suspends the calling thread until the mutex is unlocked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lthread__api_8h.html#af07d3cba5685e6cd01c71f22e42a6f31" title="Initialize a mutex. ">lthread_mutex_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to pointer to the mutex to be initialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL mutex was not an initialized mutex EDEADLOCK the mutex was already owned by the calling thread </dd></dl>

</div>
</div>
<a id="aa3c42adb8e2bc9862ded32cef1b2b8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c42adb8e2bc9862ded32cef1b2b8c2">&sect;&nbsp;</a></span>lthread_mutex_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_mutex_trylock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlthread__mutex.html">lthread_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to lock a mutex. </p>
<p>This function attempts to lock a mutex. lthread_mutex_trylock behaves identically to rte_thread_mutex_lock, except that it does not block the calling thread if the mutex is already locked by another thread.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lthread__api_8h.html#af07d3cba5685e6cd01c71f22e42a6f31" title="Initialize a mutex. ">lthread_mutex_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to pointer to the mutex to be initialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL mutex was not an initialized mutex EBUSY the mutex was already locked by another thread </dd></dl>

</div>
</div>
<a id="a2c9dc7cc0c0cfe58ac1babf3e536f6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9dc7cc0c0cfe58ac1babf3e536f6c7">&sect;&nbsp;</a></span>lthread_mutex_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlthread__mutex.html">lthread_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a mutex. </p>
<p>This function attempts to unlock the specified mutex. The mutex is assumed to be locked and owned by the calling thread.</p>
<p>The oldest of any threads blocked on the mutex is made ready and may compete with any other running thread to gain the mutex, it fails it will be blocked again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to pointer to the mutex to be initialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 mutex was unlocked EINVAL mutex was not an initialized mutex EPERM the mutex was not owned by the calling thread </dd></dl>

</div>
</div>
<a id="ae1a9eb185d9bb5c8275e35c07948b144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a9eb185d9bb5c8275e35c07948b144">&sect;&nbsp;</a></span>lthread_num_schedulers_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_num_schedulers_set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of schedulers in the system. </p>
<p>This function may optionally be called before starting schedulers.</p>
<p>If the number of schedulers is not set, or set to 0 then each scheduler will begin scheduling lthreads immediately it is started.</p>
<p>If the number of schedulers is set to greater than 0, then each scheduler will wait until all schedulers have started before beginning to schedule lthreads.</p>
<p>If an application wishes to have threads migrate between cores using <a class="el" href="lthread__api_8h.html#a58856cb3156fd41e1c6ce1122cdb2cab" title="Migrate the current thread to another scheduler. ">lthread_set_affinity()</a>, or join threads running on other cores using <a class="el" href="lthread__api_8h.html#a93da252572a8bbcf09ec8ed6f30fc1eb" title="Join an lthread. ">lthread_join()</a>, then it is prudent to set the number of schedulers to ensure that all schedulers are initialised beforehand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>the number of schedulers in the system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of schedulers in the system </dd></dl>

</div>
</div>
<a id="a1a080a2c42b92e0a35cbf0870a79c250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a080a2c42b92e0a35cbf0870a79c250">&sect;&nbsp;</a></span>lthread_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lthread_run </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the lthread scheduler. </p>
<p>Runs the lthread scheduler. This function returns only if/when all lthreads have exited. This function must be the main loop of an EAL thread.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a1289a65648e2b805ee472cf302449a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1289a65648e2b805ee472cf302449a47">&sect;&nbsp;</a></span>lthread_scheduler_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lthread_scheduler_shutdown </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>lcoreid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown the specified scheduler. </p>
<p>This function tells the specified scheduler to exit if/when there is no more work to do.</p>
<p>Note that although the scheduler will stop resources are not freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lcore</td><td>The lcore of the scheduler to shutdown</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<p>Shutdown the specified scheduler. </p>

</div>
</div>
<a id="ad69cb580350eda934d2753d61ae1289b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69cb580350eda934d2753d61ae1289b">&sect;&nbsp;</a></span>lthread_scheduler_shutdown_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lthread_scheduler_shutdown_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown all schedulers. </p>
<p>This function tells all schedulers including the current scheduler to exit if/when there is no more work to do.</p>
<p>Note that although the schedulers will stop resources are not freed.</p>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<p>Shutdown all schedulers. </p>

</div>
</div>
<a id="a58856cb3156fd41e1c6ce1122cdb2cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58856cb3156fd41e1c6ce1122cdb2cab">&sect;&nbsp;</a></span>lthread_set_affinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_set_affinity </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>lcore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate the current thread to another scheduler. </p>
<p>This function migrates the current thread to another scheduler. Execution will switch to the next lthread that is ready to run on the current scheduler. The current thread will be resumed on the new scheduler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lcore</td><td>The lcore to migrate to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success we are now running on the specified core EINVAL the destination lcore was not valid </dd></dl>

</div>
</div>
<a id="a7a265712b883d26d6557af822a9d30e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a265712b883d26d6557af822a9d30e9">&sect;&nbsp;</a></span>lthread_set_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lthread_set_data </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate user data with an lthread. </p>
<p>This function sets a user data pointer in the current lthread The pointer can be retrieved with <a class="el" href="lthread__api_8h.html#a2587090a89756fbb9a2db0d9dc869b4b" title="Get user data for the current lthread. ">lthread_get_data()</a> It is the users responsibility to allocate and free any data referenced by the user pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to user data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a1c993ca01086ed9b9615dc73e1036285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c993ca01086ed9b9615dc73e1036285">&sect;&nbsp;</a></span>lthread_setspecific()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lthread_setspecific </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set lthread TLS. </p>
<p>This function is modelled on pthread_set_sepcific() It associates a thread-specific value with a key obtained via a previous call to <a class="el" href="lthread__api_8h.html#aa7cc63807dae84772dfecec041911c22" title="Create a key for lthread TLS. ">lthread_key_create()</a>. Different threads may bind different values to the same key. These values are typically pointers to dynamically allocated memory that have been reserved by the calling thread. Calling lthread_setspecific with a key value not obtained from lthread_key_create or after the key has been deleted with lthread_key_delete will result in undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key for which data is to be set </td></tr>
    <tr><td class="paramname">key</td><td>Pointer to the user data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL the key was invalid </dd></dl>

</div>
</div>
<a id="a6ebcb5c57b7930ef2658bf9c497c054b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ebcb5c57b7930ef2658bf9c497c054b">&sect;&nbsp;</a></span>lthread_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lthread_sleep </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nsecs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause the current lthread to sleep for n nanoseconds. </p>
<p>The current thread will be suspended until the specified time has elapsed or has been exceeded.</p>
<p>Execution will switch to the next lthread that is ready to run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nsecs</td><td>Number of nanoseconds to sleep</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a7acc3b3330ec5c4e9682d4f2fef15d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acc3b3330ec5c4e9682d4f2fef15d63">&sect;&nbsp;</a></span>lthread_sleep_clks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lthread_sleep_clks </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>clks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause the current lthread to sleep for n cpu clock ticks. </p>
<p>The current thread will be suspended until the specified time has elapsed or has been exceeded.</p>
<p>Execution will switch to the next lthread that is ready to run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clks</td><td>Number of clock ticks to sleep</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a92521ac051ed98eaabeb86daba988de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92521ac051ed98eaabeb86daba988de9">&sect;&nbsp;</a></span>lthread_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lthread_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the current lthread. </p>
<p>The current thread will yield and execution will switch to the next lthread that is ready to run</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae32ee1343ae4af64262de55a4c20f634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32ee1343ae4af64262de55a4c20f634">&sect;&nbsp;</a></span>__start_per_lt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char __start_per_lt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The macros below provide an alternative mechanism to access lthread local storage. </p>
<p>The macros can be used to declare define and access per lthread local storage in a similar way to the RTE_PER_LCORE macros which control storage local to an lcore.</p>
<p>Memory for per lthread variables declared in this way is allocated when the lthread is created and a pointer to this memory is stored in the lthread. The per lthread variables are accessed via the pointer + the offset of the particular variable.</p>
<p>The total size of per lthread storage, and the variable offsets are found by defining the variables in a unique global memory section, the start and end of which is known. This global memory section is used only in the computation of the addresses of the lthread variables, and is never actually used to store any data.</p>
<p>Due to the fact that variables declared this way may be scattered across many files, the start and end of the section and variable offsets are only known after linking, thus the computation of section size and variable addresses is performed at run time.</p>
<p>These macros are primarily provided to aid porting of code that makes use of the existing RTE_PER_LCORE macros. In principle it would be more efficient to gather all lthread local variables into a single structure and set/retrieve a pointer to that struct using the alternative lthread_data_set/get APIs.</p>
<p>These macros are mutually exclusive with the lthread_data_set/get APIs. If you define storage using these macros then the lthread_data_set/get APIs will not perform as expected, the lthread_data_set API does nothing, and the lthread_data_get API returns the start of global section. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
